# CS_HW2 — Клиент-Сервер с TCP и UDP

Учебный проект в рамках курса курса "современные компьютерные сети". Реализован простой клиент-сервер, который может общаться по протоколам **TCP** и **UDP** с помощью Python-сокетов.  

- Сервер принимает сообщения и отправляет ответ.
- Клиент может отправлять сообщения серверу и получать ответ.
- Протокол сообщений: клиент отправляет строку, сервер отвечает в формате `"Got: <message>"`.

---

## Описание проекта

В проекте реализован простой протокол для TCP и UDP. 

В случае TCP каждое сообщение состоит из 4-байтового заголовка, который указывает длину полезной нагрузки в байтах (big-endian), и самой полезной нагрузки в UTF-8. Это нужно, так как TCP передаёт данные как поток байтов, и для корректного определения границ сообщения нужно указывать его длину.. Клиент и сервер используют одинаковый формат для отправки и получения сообщений. Например, строка "Hi!" передаётся как `00 00 00 03 48 69 21`, где `00 00 00 03` — длина сообщения, а `48 69 21` — кодировка символов.

Как реализовано:
1) Клиент создаёт соединение с сервером (`socket.create_connection`).
2) Клиент отправляет сообщение через `send_msg()`.
3) Сервер получает сообщение через `recv_msg()`, обрабатывает его и формирует ответ.
4) Сервер отправляет ответ клиенту с тем же форматом (`send_msg()`).
5) Клиент принимает ответ через `recv_msg()` и отображает его в терминале.

Для UDP каждое сообщение отправляется как отдельная датаграмма в UTF-8, поэтому длина в заголовке не указывается. Сервер обрабатывает каждое UDP-сообщение целиком и отвечает шаблоном `Got it! I also <сообщение>`.
Как реализовано:
1) Клиент формирует датаграмму с сообщением и отправляет её серверу (`sendto()`).
2) Сервер получает датаграмму через `recvfrom()`, обрабатывает её и формирует ответ.
3) Сервер отправляет ответ клиенту в виде новой датаграммы (`sendto()`).
4) Клиент получает ответ и выводит его в терминал.

Некоторые детали:
- Протокол поддерживает пустые сообщения;
- TCP позволяет передавать достаточно большие сообщения (например, более 20 КБ);
- Протокол совместим с netcat.

## Как работает приложение

1) Сервер запускается и начинает слушать выбранный порт (по умолчанию 8888).
- Для TCP: сервер ждёт входящих соединений (`listen` + `accept`).
- Для UDP: сервер ждёт входящих датаграмм (`recvfrom`).

2) Клиент подключается к серверу:
- Для TCP: создаётся соединение через `socket.create_connection`.
- Для UDP: клиент просто отправляет пакет на адрес сервера.

3) Клиент и сервер обмениваются сообщениями:
- В TCP клиент отправляет строку, сервер получает и отвечает с шаблоном `Got it! I also <сообщение>`.
- В UDP клиент отправляет пакет, сервер получает и отправляет ответ в том же формате.

4) Все сообщения выводятся в терминал в реальном времени:
- Сервер показывает, что получил сообщение от клиента.
- Клиент показывает ответ сервера.

5) Для выхода из клиентской программы достаточно ввести exit.

## Требования

- Python 3.8+  
- `netcat` (`nc`) для ручной проверки UDP/TCP (опционально)  
- Git  

---

## Установка и запуск

1. Клонируем репозиторий:

```bash
git clone https://github.com/KuchinaMA/ClientServerApp.git
cd CLientServerApp
```

2. Запуск сервера или клиента:
- TCP сервер (порт 8888 по умолчанию):

```
python3 main.py --role server --protocol tcp --port 8888
```

- TCP клиент

```
python3 main.py --role client --protocol tcp --host localhost --port 8888
```

- UDP сервер

```
python3 main.py --role server --protocol udp --port 8888
```

- UDP клиент

```
python3 main.py --role client --protocol udp --host localhost --port 8888
```
В клиенте можно писать сообщения, чтобы отправлять их серверу.
Для выхода из клиента введите `exit`.

## Тестирование

1. Убедитесь, что на вашей системе установлен `Python3` и `nc`.

2. Перейдите в папку проекта:

```
cd CS_HW2
```

3. Запуск тестов
```
python3 tests/run_all_tests.py
```

4. Пример вывода тетов:
```
[TCP] small message          PASSED
[TCP] large message          PASSED
[UDP] netcat compatibility   PASSED
```